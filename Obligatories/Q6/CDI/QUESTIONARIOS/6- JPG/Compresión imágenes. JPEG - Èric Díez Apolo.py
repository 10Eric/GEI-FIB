import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import hadamard
from scipy.fftpack import dct, idct


def es_ortogonal(matriz, tol=1e-6):
    A = np.array(matriz)
    identidad = np.eye(A.shape[0])
    return np.allclose(A.T @ A, identidad, atol=tol)

def identificar_matriz_ortogonal():
    a = [[-0.2540003, 0.407909, -0.276164, -0.4312091, -0.22538, 0.6703836, -0.0815597, -0.004893],
        [0.1270001, -0.2997513, -0.6523844, -0.1313585, -0.0491681, -0.0702241, 0.5864383, -0.3160709],
        [0.5080005, 0.7169309, -0.0758389, 0.3058357, 0.2492577, 0.0363317, 0.2544939, -0.021023],
        [0.1270001, -0.1081577, 0.2109468, -0.6125604, 0.6630851, 0.0575482, 0.2134077, 0.2527994],
        [0.2540003, -0.0247218, 0.448023, -0.2170045, -0.0791093, 0.1176633, -0.0497322, -0.815157],
        [-0.5080005, 0.4326307, -0.1261857, -0.2327107, 0.1750326, -0.609125, -0.0702287, -0.2794409],
        [0.5080005, -0.0494435, -0.4195569, -0.2602585, 0.0184331, -0.1937246, -0.6765791, 0.0100053],
        [0.2540003, 0.1668719, 0.2349519, -0.3988211, -0.6385456, -0.3444059, 0.2719625, 0.3050533]]
        
    b = [[0.4541144, 0.0163354, -0.0779752, -0.3112032, 0.168496, -0.3839146, -0.0579913, 0.0896629],
        [0.200353, -0.001693, -0.2235212, -0.1418874, -0.226144, -0.0318805, -0.2887178, 0.4599711],
        [-0.4148674, 0.4547298, 0.3634873, -0.1321529, -0.4255289, -0.0553521, 0.0963863, -0.3444806],
        [-0.142478, -0.1835372, -0.2591975, 0.3750644, -0.4634734, -0.1098493, -0.4267593, -0.0705734],
        [0.1149576, -0.378752, -0.3714987, 0.3931375, -0.2114053, -0.2976358, 0.0076651, -0.1489997],
        [-0.0813792, -0.0701367, 0.4370406, -0.0502712, -0.4509614, -0.3601558, -0.2883847, -0.0631563],
        [-0.2487301, -0.4549586, 0.1208339, -0.3868891, -0.3041156, -0.1757121, -0.0392297, -0.1398845],
        [0.084773, 0.2132033, 0.2884081, 0.4802997, -0.2647551, 0.0592672, 0.1261681, -0.2924598]]
    
    c = [[0.0843623, 0.2088295, -0.5728799, -0.6874959, -0.3229872, 0.0163291, -0.1246965, -0.1498172],
        [-0.3316448, -0.5070796, -0.6880032, -0.640262, -0.2904753, -0.2126717, -0.3937496, -0.3934658],
        [-0.3042113, 0.1218384, -0.3157235, -0.6366114, -0.4839235, -0.6580403, -0.5436032, -0.5791269],
        [0.0201608, 0.0619719, -0.5181293, -0.2994047, -0.5398551, -0.1708185, -0.3546424, 0.2251318],
        [0.0365634, 0.0776235, -0.5382646, -0.5674015, -0.6618779, 0.0865601, 0.1295281, -0.2564319],
        [-0.2809497, -0.3513216, 0.0282804, -0.4745383, -0.5790903, -0.3048256, 0.0066023, 0.0286363],
        [0.043572, -0.6408768, -0.7183342, -0.5737765, -0.7019597, -0.3218107, -0.4151537, -0.3755271],
        [0.2018955, -0.0762083, -0.6351164, -0.162417, -0.2519107, -0.7150666, -0.0805515, -0.2615354]]
    
    matrices = {'a': a, 'b': b, 'c': c}
    
    for clave, matriz in matrices.items():
        if es_ortogonal(matriz):
            print(f"La matriz {clave} define una transformación ortogonal.")
            return clave
    print("Ninguna de las matrices es ortogonal.")
    return None

def show_all_dwht_candidates():
    options = {
        'a': np.array([
            [0.0, 0.0, -1.0, 0.0],
            [0.0, 0.0, 0.0, -1.0],
            [0.70711, 0.70711, 0.0, 0.0],
            [0.70711, -0.70711, 0.0, 0.0]
        ]),
        'b': np.array([
            [-1.73205, -0.57735, -1.1547, -1.1547],
            [0.0, -0.8165, -0.40825, -0.40825],
            [0.0, 0.0, -0.70711, -0.70711],
            [0.0, 0.0, 0.0, -1.0]
        ]),
        'c': np.array([
            [0.0, 0.0, 0.0, 1.0],
            [0.57735, -0.40825, 0.70711, 0.0],
            [0.57735, -0.40825, -0.70711, 0.0],
            [0.57735, 0.8165, 0.0, 0.0]
        ])
    }

    fig, axes = plt.subplots(3, 16, figsize=(20, 6))
    plt.suptitle("16 bloques base (fila × filaᵗ) por opción", fontsize=16)

    for row, (opt_name, matrix) in enumerate(options.items()):
        count = 0
        for i in range(4):
            for j in range(4):
                basis_image = np.outer(matrix[i], matrix[j])
                ax = axes[row, count]
                ax.imshow(basis_image, cmap=plt.cm.gray, vmin=-1, vmax=1)
                ax.set_title(f"{opt_name}: {i}×{j}", fontsize=7)
                ax.axis('off')
                count += 1

    plt.tight_layout()
    plt.show()


def show_inverse_reconstruction_candidates():
    options = {
        'a': np.array([
            [-0.57735, 0.2582, -0.7746, 0.0],
            [-0.57735, -0.5164, 0.2582, -0.57735],
            [0.0, -0.7746, -0.2582, 0.57735],
            [-0.57735, 0.2582, 0.5164, 0.57735]
        ]),
        'b': np.array([
            [1.73205, 1.1547, 1.1547, 0.57735],
            [0.0, 1.29099, -0.2582, 0.2582],
            [0.0, 0.0, 0.7746, 0.5164],
            [0.0, 0.0, 0.0, 0.57735]
        ]),
        'c': np.array([
            [-0.57735, -0.2582, 0.7746, 0.0],
            [-0.57735, -0.2582, -0.5164, -0.57735],
            [-0.57735, 0.5164, -0.2582, 0.57735],
            [0.0, -0.7746, -0.2582, 0.57735]
        ])
    }

    fig, axes = plt.subplots(3, 16, figsize=(16, 6))
    plt.suptitle("Reconstrucción inversa de los 16 bloques base (por opción)", fontsize=14)

    for row, (opt_name, T) in enumerate(options.items()):
        for i in range(4):
            for j in range(4):
                coef = np.zeros((4, 4))
                coef[i, j] = 1
                spatial_block = T.T @ coef @ T
                ax = axes[row, 4 * i + j]
                ax.imshow(spatial_block, cmap=plt.cm.gray, vmin=-1, vmax=1)
                ax.set_title(f"{opt_name} ({i},{j})", fontsize=6)
                ax.axis('off')

    plt.tight_layout()
    plt.show()



def sequency_order(H):
    """Reordena las filas de la matriz de Hadamard al orden de secuencia (número de cambios de signo)."""
    def cambios_signo(fila):
        return np.sum(np.diff(fila) != 0)
    indices = sorted(range(H.shape[0]), key=lambda i: cambios_signo(H[i]))
    return H[indices]

def get_indices_C(C):
    """Devuelve los índices (i, j) tal que i + j < C en orden fila-columna."""
    return [(i, j) for i in range(C) for j in range(C) if i + j < C]

def bits_to_int16_list(bits):
    """Convierte una cadena de bits a una lista de enteros con signo (16 bits)."""
    valores = []
    for i in range(0, len(bits), 16):
        b = bits[i:i+16]
        v = int(b, 2)
        if b[0] == '1':  # negativo en complemento a 2
            v -= (1 << 16)
        valores.append(v)
    return valores

def decodifica_imagen_wh_corregida(bits):
    """Función principal para decodificar imagen comprimida con Walsh-Hadamard."""
    # Encabezado
    n = int(bits[0:16], 2)
    m = int(bits[16:32], 2)
    n_b = int(bits[32:40], 2)
    C = int(bits[40:48], 2)

    bloques_x = m // n_b
    bloques_y = n // n_b
    total_bloques = bloques_x * bloques_y
    num_coef = C * (C + 1) // 2
    bloque_bits = num_coef * 16

    # Matriz de Hadamard normalizada y en orden de secuencia
    H_base = hadamard(n_b).astype(np.float32)
    H = sequency_order(H_base) / np.sqrt(n_b)

    # Preparamos imagen destino
    imagen = np.zeros((n, m), dtype=np.uint8)

    indices = get_indices_C(C)
    bit_offset = 48

    for by in range(bloques_y):
        for bx in range(bloques_x):
            bloque_bin = bits[bit_offset:bit_offset + bloque_bits]
            bit_offset += bloque_bits
            coef = bits_to_int16_list(bloque_bin)

            bloque = np.zeros((n_b, n_b), dtype=np.float32)
            for idx, (i, j) in enumerate(indices):
                bloque[i, j] = coef[idx]

            # Inversa de la transformación
            bloque_rec = H.T @ bloque @ H
            bloque_rec += 128
            bloque_rec = np.clip(np.round(bloque_rec), 0, 255).astype(np.uint8)

            y = by * n_b
            x = bx * n_b
            imagen[y:y+n_b, x:x+n_b] = bloque_rec

    return imagen



# Matriz de cuantización estándar luminancia (JPEG)
Q_L = np.array([
    [16,11,10,16,24,40,51,61],
    [12,12,14,19,26,58,60,55],
    [14,13,16,24,40,57,69,56],
    [14,17,22,29,51,87,80,62],
    [18,22,37,56,68,109,103,77],
    [24,35,55,64,81,104,113,92],
    [49,64,78,87,103,121,120,101],
    [72,92,95,98,112,100,103,99]
])

def dct2(block):
    return dct(dct(block.T, norm='ortho').T, norm='ortho')

def idct2(block):
    return idct(idct(block.T, norm='ortho').T, norm='ortho')

def simular_jpeg_bloque(bloque):
    # Restar 128
    bloque = bloque.astype(np.float32) - 128

    # DCT
    bloque_dct = dct2(bloque)

    # Cuantización
    bloque_cuant = np.round(bloque_dct / Q_L)

    # Descuantización
    bloque_dct_rec = bloque_cuant * Q_L

    # IDCT
    bloque_rec = idct2(bloque_dct_rec)

    # Sumar 128 y clip
    bloque_final = np.clip(np.round(bloque_rec + 128), 0, 255).astype(np.uint8)

    return bloque_final

HUFFMAN_AC_LUMINANCE = {
    (0,0): '1010',  (0,1): '00',      (0,2): '01',      (0,3): '100',
    (0,4): '1011',  (0,5): '11010',   (0,6): '1111000', (0,7): '11111000',
    (0,8): '1111110110', (0,9): '1111111110000010', (0,10): '1111111110000011',
    (1,1): '1100',  (1,2): '11011',   (1,3): '1111001', (1,4): '111110110',
    (1,5): '11111110110', (1,6): '1111111110000100', (1,7): '1111111110000101',
    (1,8): '1111111110000110', (1,9): '1111111110000111', (1,10): '1111111110001000',
    (2,1): '11100', (2,2): '11111001', (2,3): '1111110111', (2,4): '111111110100',
    (2,5): '1111111110001001', (2,6): '1111111110001010', (2,7): '1111111110001011',
    (2,8): '1111111110001100', (2,9): '1111111110001101', (2,10): '1111111110001110',
    (3,1): '111010', (3,2): '111110111', (3,3): '111111110101',
    (3,4): '1111111110001111', (3,5): '1111111110010000', (3,6): '1111111110010001',
    (3,7): '1111111110010010', (3,8): '1111111110010011', (3,9): '1111111110010100',
    (3,10): '1111111110010101',
    (4,1): '111011', (4,2): '1111111000', (4,3): '1111111110010110',
    (4,4): '1111111110010111', (4,5): '1111111110011000', (4,6): '1111111110011001',
    (4,7): '1111111110011010', (4,8): '1111111110011011', (4,9): '1111111110011100',
    (4,10): '1111111110011101',
    (5,1): '1111010', (5,2): '11111110111', (5,3): '1111111110011110',
    (5,4): '1111111110011111', (5,5): '1111111110100000', (5,6): '1111111110100001',
    (5,7): '1111111110100010', (5,8): '1111111110100011', (5,9): '1111111110100100',
    (5,10): '1111111110100101',
    (6,1): '1111011', (6,2): '111111110110', (6,3): '1111111110100110',
    (6,4): '1111111110100111', (6,5): '1111111110101000', (6,6): '1111111110101001',
    (6,7): '1111111110101010', (6,8): '1111111110101011', (6,9): '1111111110101100',
    (6,10): '1111111110101101',
    (7,1): '11111010', (7,2): '111111110111', (7,3): '1111111110101110',
    (7,4): '1111111110101111', (7,5): '1111111110110000', (7,6): '1111111110110001',
    (7,7): '1111111110110010', (7,8): '1111111110110011', (7,9): '1111111110110100',
    (7,10): '1111111110110101',
    (8,1): '111111000', (8,2): '111111111000000', (8,3): '1111111110110110',
    (8,4): '1111111110110111', (8,5): '1111111110111000', (8,6): '1111111110111001',
    (8,7): '1111111110111010', (8,8): '1111111110111011', (8,9): '1111111110111100',
    (8,10): '1111111110111101',
    (9,1): '111111001', (9,2): '1111111110111110', (9,3): '1111111110111111',
    (9,4): '1111111111000000', (9,5): '1111111111000001', (9,6): '1111111111000010',
    (9,7): '1111111111000011', (9,8): '1111111111000100', (9,9): '1111111111000101',
    (9,10): '1111111111000110',
    (10,1): '111111010', (10,2): '1111111111000111', (10,3): '1111111111001000',
    (10,4): '1111111111001001', (10,5): '1111111111001010', (10,6): '1111111111001011',
    (10,7): '1111111111001100', (10,8): '1111111111001101', (10,9): '1111111111001110',
    (10,10): '1111111111001111',
    (11,1): '1111111001', (11,2): '1111111111010000', (11,3): '1111111111010001',
    (11,4): '1111111111010010', (11,5): '1111111111010011', (11,6): '1111111111010100',
    (11,7): '1111111111010101', (11,8): '1111111111010110', (11,9): '1111111111010111',
    (11,10): '1111111111011000',
    (12,1): '1111111010', (12,2): '1111111111011001', (12,3): '1111111111011010',
    (12,4): '1111111111011011', (12,5): '1111111111011100', (12,6): '1111111111011101',
    (12,7): '1111111111011110', (12,8): '1111111111011111', (12,9): '1111111111100000',
    (12,10): '1111111111100001',
    (13,1): '11111111000', (13,2): '1111111111100010', (13,3): '1111111111100011',
    (13,4): '1111111111100100', (13,5): '1111111111100101', (13,6): '1111111111100110',
    (13,7): '1111111111100111', (13,8): '1111111111101000', (13,9): '1111111111101001',
    (13,10): '1111111111101010',
    (14,1): '1111111111101011', (14,2): '1111111111101100', (14,3): '1111111111101101',
    (14,4): '1111111111101110', (14,5): '1111111111101111', (14,6): '1111111111110000',
    (14,7): '1111111111110001', (14,8): '1111111111110010', (14,9): '1111111111110011',
    (14,10): '1111111111110100',
    (15,0): '11111111001',  # ZRL
    (15,1): '1111111111110101', (15,2): '1111111111110110', (15,3): '1111111111110111',
    (15,4): '1111111111111000', (15,5): '1111111111111001', (15,6): '1111111111111010',
    (15,7): '1111111111111011', (15,8): '1111111111111100', (15,9): '1111111111111101',
    (15,10): '1111111111111110',
}

def valor_binario_jpeg(x):
    """Devuelve el valor binario JPEG del entero x (como string de longitud s)."""
    if x > 0:
        return format(x, f'0{len(format(x, "b"))}b')
    else:
        s = len(format(abs(x), 'b'))
        return ''.join('1' if b == '0' else '0' for b in format(abs(x), f'0{s}b'))

def huffman_codigo(z, s):
    """Tabla parcial de Huffman para luminancia AC, simplificada (clave: (z, s))."""
    tabla = {
        (0,0): '1010',  (0,1): '00',      (0,2): '01',      (0,3): '100',
    (0,4): '1011',  (0,5): '11010',   (0,6): '1111000', (0,7): '11111000',
    (0,8): '1111110110', (0,9): '1111111110000010', (0,10): '1111111110000011',
    (1,1): '1100',  (1,2): '11011',   (1,3): '1111001', (1,4): '111110110',
    (1,5): '11111110110', (1,6): '1111111110000100', (1,7): '1111111110000101',
    (1,8): '1111111110000110', (1,9): '1111111110000111', (1,10): '1111111110001000',
    (2,1): '11100', (2,2): '11111001', (2,3): '1111110111', (2,4): '111111110100',
    (2,5): '1111111110001001', (2,6): '1111111110001010', (2,7): '1111111110001011',
    (2,8): '1111111110001100', (2,9): '1111111110001101', (2,10): '1111111110001110',
    (3,1): '111010', (3,2): '111110111', (3,3): '111111110101',
    (3,4): '1111111110001111', (3,5): '1111111110010000', (3,6): '1111111110010001',
    (3,7): '1111111110010010', (3,8): '1111111110010011', (3,9): '1111111110010100',
    (3,10): '1111111110010101',
    (4,1): '111011', (4,2): '1111111000', (4,3): '1111111110010110',
    (4,4): '1111111110010111', (4,5): '1111111110011000', (4,6): '1111111110011001',
    (4,7): '1111111110011010', (4,8): '1111111110011011', (4,9): '1111111110011100',
    (4,10): '1111111110011101',
    (5,1): '1111010', (5,2): '11111110111', (5,3): '1111111110011110',
    (5,4): '1111111110011111', (5,5): '1111111110100000', (5,6): '1111111110100001',
    (5,7): '1111111110100010', (5,8): '1111111110100011', (5,9): '1111111110100100',
    (5,10): '1111111110100101',
    (6,1): '1111011', (6,2): '111111110110', (6,3): '1111111110100110',
    (6,4): '1111111110100111', (6,5): '1111111110101000', (6,6): '1111111110101001',
    (6,7): '1111111110101010', (6,8): '1111111110101011', (6,9): '1111111110101100',
    (6,10): '1111111110101101',
    (7,1): '11111010', (7,2): '111111110111', (7,3): '1111111110101110',
    (7,4): '1111111110101111', (7,5): '1111111110110000', (7,6): '1111111110110001',
    (7,7): '1111111110110010', (7,8): '1111111110110011', (7,9): '1111111110110100',
    (7,10): '1111111110110101',
    (8,1): '111111000', (8,2): '111111111000000', (8,3): '1111111110110110',
    (8,4): '1111111110110111', (8,5): '1111111110111000', (8,6): '1111111110111001',
    (8,7): '1111111110111010', (8,8): '1111111110111011', (8,9): '1111111110111100',
    (8,10): '1111111110111101',
    (9,1): '111111001', (9,2): '1111111110111110', (9,3): '1111111110111111',
    (9,4): '1111111111000000', (9,5): '1111111111000001', (9,6): '1111111111000010',
    (9,7): '1111111111000011', (9,8): '1111111111000100', (9,9): '1111111111000101',
    (9,10): '1111111111000110',
    (10,1): '111111010', (10,2): '1111111111000111', (10,3): '1111111111001000',
    (10,4): '1111111111001001', (10,5): '1111111111001010', (10,6): '1111111111001011',
    (10,7): '1111111111001100', (10,8): '1111111111001101', (10,9): '1111111111001110',
    (10,10): '1111111111001111',
    (11,1): '1111111001', (11,2): '1111111111010000', (11,3): '1111111111010001',
    (11,4): '1111111111010010', (11,5): '1111111111010011', (11,6): '1111111111010100',
    (11,7): '1111111111010101', (11,8): '1111111111010110', (11,9): '1111111111010111',
    (11,10): '1111111111011000',
    (12,1): '1111111010', (12,2): '1111111111011001', (12,3): '1111111111011010',
    (12,4): '1111111111011011', (12,5): '1111111111011100', (12,6): '1111111111011101',
    (12,7): '1111111111011110', (12,8): '1111111111011111', (12,9): '1111111111100000',
    (12,10): '1111111111100001',
    (13,1): '11111111000', (13,2): '1111111111100010', (13,3): '1111111111100011',
    (13,4): '1111111111100100', (13,5): '1111111111100101', (13,6): '1111111111100110',
    (13,7): '1111111111100111', (13,8): '1111111111101000', (13,9): '1111111111101001',
    (13,10): '1111111111101010',
    (14,1): '1111111111101011', (14,2): '1111111111101100', (14,3): '1111111111101101',
    (14,4): '1111111111101110', (14,5): '1111111111101111', (14,6): '1111111111110000',
    (14,7): '1111111111110001', (14,8): '1111111111110010', (14,9): '1111111111110011',
    (14,10): '1111111111110100',
    (15,0): '11111111001',  # ZRL
    (15,1): '1111111111110101', (15,2): '1111111111110110', (15,3): '1111111111110111',
    (15,4): '1111111111111000', (15,5): '1111111111111001', (15,6): '1111111111111010',
    (15,7): '1111111111111011', (15,8): '1111111111111100', (15,9): '1111111111111101',
    (15,10): '1111111111111110',
    }
    return tabla.get((z, s), f'[HUFF({z},{s})]')  # si falta, marcamos

def codifica_AC_jpeg(ac_list):
    """Codifica los coeficientes AC según JPEG (simplificado)."""
    binario = ''
    z = 0
    for x in ac_list:
        if x == 0:
            z += 1
            if z == 16:
                binario += huffman_codigo(15, 0)
                z = 0
        else:
            s = len(format(abs(x), 'b'))
            huff = huffman_codigo(z, s)
            val = valor_binario_jpeg(x)
            binario += huff + val
            z = 0
    
    binario += huffman_codigo(0, 0)
    return binario

def invertir_tabla_huffman(huffman_table):
    return {v: k for k, v in huffman_table.items()}

HUFFMAN_INV = invertir_tabla_huffman(HUFFMAN_AC_LUMINANCE)

def bits_a_valor(bits):
    """Convierte una cadena de bits a valor JPEG."""
    if not bits:
        return 0
    if bits[0] == '1':
        return int(bits, 2)
    else:
        # negativo en JPEG
        return -((1 << len(bits)) - int(bits, 2) - 1)

def decodifica_AC_jpeg(bits):
    """Decodifica la lista de coeficientes AC desde el binario."""
    i = 0
    coef = []
    while i < len(bits):
        # Buscar prefijo Huffman
        encontrado = False
        for j in range(2, 17):
            prefix = bits[i:i+j]
            if prefix in HUFFMAN_INV:
                z, s = HUFFMAN_INV[prefix]
                i += j
                encontrado = True
                if (z, s) == (0, 0):  # EOB
                    return coef
                if (z, s) == (15, 0):  # ZRL: 16 ceros
                    coef.extend([0]*16)
                    break
                # Leer s bits para el valor
                val_bits = bits[i:i+s]
                if len(val_bits) < s:
                    raise ValueError("No hay suficientes bits para el valor")
                val = bits_a_valor(val_bits)
                i += s
                coef.extend([0]*z)
                coef.append(val)
                break
        if not encontrado:
            raise ValueError(f"No se encontró Huffman válido en el índice {i}")
    return coef

def huffman_DC_luminancia():
    return {
        0:  '0',
        1:  '10',
        2:  '110',
        3:  '1110',
        4:  '11110',
        5:  '111110',
        6:  '1111110',
        7:  '11111110',
        8:  '111111110',
        9:  '1111111110',
        10: '11111111110',
        11: '111111111110',
        12: '1111111111110',
        13: '11111111111110',
        14: '111111111111110',
        15: '1111111111111110',
        16: '1111111111111111'
    }

def valor_binario_jpeg(x):
    """Codifica un entero como binario JPEG (complemento invertido para negativos)."""
    if x == 0:
        return ''
    s = len(format(abs(x), 'b'))
    if x > 0:
        return format(x, f'0{s}b')
    else:
        return ''.join('1' if b == '0' else '0' for b in format(abs(x), f'0{s}b'))

def categoria(x):
    """Calcula la categoría (número de bits) para el valor x."""
    if x == 0:
        return 0
    return len(format(abs(x), 'b'))

def codifica_DC_jpeg(dc_list):
    """Codifica lista de coeficientes DC según JPEG."""
    diffs = [dc_list[0]] + [dc_list[i] - dc_list[i-1] for i in range(1, len(dc_list))]
    tabla_huff = huffman_DC_luminancia()

    resultado = ''
    for d in diffs:
        s = categoria(d)
        huff = tabla_huff[s]
        val_bits = valor_binario_jpeg(d)
        resultado += huff + val_bits
    return resultado

def decode_dc_coefficients(bitstream: str) -> int:
    # Tabla Huffman extendida
    HUFFMAN_DC_EXTENDIDA = {
        0:  '0',
        1:  '10',
        2:  '110',
        3:  '1110',
        4:  '11110',
        5:  '111110',
        6:  '1111110',
        7:  '11111110',
        8:  '111111110',
        9:  '1111111110',
        10: '11111111110',
        11: '111111111110',
        12: '1111111111110',
        13: '11111111111110',
        14: '111111111111110',
        15: '1111111111111110',
        16: '1111111111111111'
    }

    # Invertimos la tabla para buscar por prefijo
    HUFFMAN_INV = {v: k for k, v in HUFFMAN_DC_EXTENDIDA.items()}

    i = 0
    prev_dc = 0
    total = 0
    n = len(bitstream)

    while i < n:
        # Buscar código Huffman
        found = False
        for l in range(1, 16):  # buscar longitudes posibles
            if i + l > n:
                break
            prefix = bitstream[i:i+l]
            if prefix in HUFFMAN_INV:
                category = HUFFMAN_INV[prefix]
                i += l
                found = True
                break

        if not found:
            break  # fin o error

        # Leer los bits de magnitud según la categoría
        if category == 0:
            diff = 0
        else:
            if i + category > n:
                break  # fuera de rango
            magnitude_bits = bitstream[i:i+category]
            i += category

            if magnitude_bits[0] == '1':
                diff = int(magnitude_bits, 2)
            else:
                # Número negativo: invertir bits
                inverted = ''.join('1' if b == '0' else '0' for b in magnitude_bits)
                diff = -int(inverted, 2)

        # Suma diferencial
        prev_dc += diff
        total += prev_dc

    return total % 256

# PREGUNTA 1 !!!
identificar_matriz_ortogonal()

# PREGUNTA 2 !!!
show_all_dwht_candidates()
show_inverse_reconstruction_candidates()

# PREGUNTA 3 !!!
with open("/home/ericdiezapolo/Escritorio/CDI/descarga", "rb") as f:
    bin_data = f.read()

bit_string = ''.join(f'{byte:08b}' for byte in bin_data)

imagen = decodifica_imagen_wh_corregida(bit_string)

# Guardar imagen
from PIL import Image
Image.fromarray(imagen).save('imagen_reconstruida.png')

# PREGUNTA 4 !!!
original = np.array([
    [54, 60, 49, 51, 55, 52, 42, 38], [54, 53, 51, 53, 48, 39, 39, 38], [70, 73, 62, 48, 41, 40, 41, 46], [74, 63, 55, 41, 40, 43, 42, 56], [62, 48, 52, 41, 38, 42, 59, 59], [41, 56, 49, 38, 39, 49, 66, 65], [48, 59, 45, 37, 46, 85, 46, 69], [60, 50, 40, 43, 64, 49, 50, 65]
])

resultado = simular_jpeg_bloque(original)
print(resultado)
print("")

# PREGUNTA 5 !!!
ac = [-9, -9, 2, 9, 0, 0, 0, -8, 4, 0, 0, 0, 0, 0, 5]
codigo = codifica_AC_jpeg(ac)
print(codigo)
print("")

# PREGUNTA 6 !!!
codigo = "110001011100011111101111100100111110111111011011011111111110100011101010"
coeficientes = decodifica_AC_jpeg(codigo)
print(coeficientes)
print("")

# PREGUNTA 7 !!!
dc = [550, 493, 584, 632, 582, 442, 442, 579, 552, 476, 590, 512, 454, 482, 450, 663, 541, 645, 497, 510, 488, 544, 459, 638, 592, 584, 460, 691, 455, 475, 476, 559, 558]
binario = codifica_DC_jpeg(dc)
print(binario)
print("")

# PREGUNTA 8 !!!
codigo = ("1111111111011110001001111011011111111101000110011111100001111111111100101101011101011110001011111110111010011100101111110001110111111010000011111110001100011111011101111111001011111111110111110011111110001101011111110101011011110111111111000011111111101111111111111100110010111001111111110001111011111101110011111011111111111001000111111110011110111101000111111110101000001100111111111001110001")
resultado = decode_dc_coefficients(codigo)
print("Resultado:", resultado)

